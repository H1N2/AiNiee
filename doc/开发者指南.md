# AiNiee 开发者指南

## 项目架构

### 核心模块架构
```
ModuleFolders/
├── FileAccessor/           # 文件访问抽象层
├── FileReader/             # 文件读取器集合
├── FileOutputer/           # 文件输出器集合
├── FileConverter/          # 文件格式转换器
├── LLMRequester/           # 大语言模型请求管理
├── TaskExecutor/           # 任务执行引擎
├── TextProcessor/          # 文本处理器
├── PromptBuilder/          # 提示词构建器
├── ResponseExtractor/      # 响应内容提取器
├── ResponseChecker/        # 响应质量检查器
├── RequestLimiter/         # 请求频率限制器
├── NERProcessor/           # 命名实体识别处理
├── TaskConfig/             # 任务配置管理
└── SimpleExecutor/         # 简单任务执行器
```

### 用户界面架构
```
UserInterface/
├── AppFluentWindow.py      # 主窗口
├── Settings/               # 设置界面
├── TranslationSettings/    # 翻译设置
├── EditView/               # 编辑视图  
├── Table/                  # 表格组件
├── NameExtractor/          # 名称提取器界面
├── PolishingSettings/      # 润色设置
├── FormatSettings/         # 格式设置
├── Extraction_Tool/        # 提取工具界面
├── TableHelper/            # 表格辅助工具
├── Platform/               # 平台相关界面
└── VersionManager/         # 版本管理
```

## 开发环境搭建

### 1. 环境要求
- Python 3.12
- Git
- 代码编辑器（推荐 VS Code 或 PyCharm）

### 2. 项目克隆与设置
```bash
git clone https://github.com/NEKOparapa/AiNiee.git
cd AiNiee
python -m venv venv
source venv/bin/activate  # Linux/Mac
# 或 venv\Scripts\activate  # Windows
pip install -r requirements.txt
```

### 3. 开发工具配置
推荐的 VS Code 扩展：
- Python
- Pylance
- Python Docstring Generator
- GitLens
- Better Comments

## 核心组件开发

### 文件读写器开发

#### Reader 开发
```python
from ModuleFolders.FileAccessor.BaseReader import BaseReader

class MyFormatReader(BaseReader):
    def __init__(self):
        super().__init__()
        
    def read_file(self, file_path: str) -> dict:
        """读取文件并返回标准格式数据"""
        # 实现文件读取逻辑
        pass
        
    def get_file_format(self) -> str:
        """返回支持的文件格式"""
        return "my_format"
        
    def is_supported_file(self, file_path: str) -> bool:
        """检查是否支持该文件"""
        return file_path.endswith('.myformat')
```

#### Writer 开发
```python
from ModuleFolders.FileAccessor.BaseWriter import BaseWriter

class MyFormatWriter(BaseWriter):
    def __init__(self):
        super().__init__()
        
    def write_file(self, data: dict, output_path: str) -> bool:
        """将数据写入文件"""
        # 实现文件写入逻辑
        pass
        
    def get_file_format(self) -> str:
        """返回支持的文件格式"""
        return "my_format"
```

### 插件开发

#### 插件基类
```python
from PluginScripts.PluginBase import PluginBase, Priority

class MyPlugin(PluginBase):
    def __init__(self):
        super().__init__()
        self.plugin_name = "MyPlugin"
        self.plugin_version = "1.0.0"
        self.plugin_author = "Your Name"
        self.plugin_description = "插件描述"
        
    def on_text_preprocess(self, text: str, context: dict) -> str:
        """文本预处理事件"""
        # 实现预处理逻辑
        return text
        
    def on_text_postprocess(self, text: str, context: dict) -> str:
        """文本后处理事件"""
        # 实现后处理逻辑
        return text
        
    def get_priority(self) -> Priority:
        """返回插件优先级"""
        return Priority.NORMAL
```

### LLM接口开发

#### 新增AI服务提供商
```python
from ModuleFolders.LLMRequester.BaseLLMRequester import BaseLLMRequester

class MyAIRequester(BaseLLMRequester):
    def __init__(self, api_key: str, base_url: str = None):
        super().__init__()
        self.api_key = api_key
        self.base_url = base_url or "https://api.myai.com"
        
    def make_request(self, messages: list, model: str = None) -> dict:
        """发送请求到AI服务"""
        # 实现API调用逻辑
        pass
        
    def get_supported_models(self) -> list:
        """返回支持的模型列表"""
        return ["my-model-1", "my-model-2"]
        
    def calculate_tokens(self, text: str) -> int:
        """计算token数量"""
        # 实现token计算逻辑
        pass
```

## 代码规范

### Python代码风格
- 遵循 PEP 8 规范
- 使用类型提示（Type Hints）
- 函数和类需要添加文档字符串

```python
def process_text(text: str, options: dict = None) -> str:
    """
    处理文本内容
    
    Args:
        text (str): 待处理的文本
        options (dict, optional): 处理选项. Defaults to None.
        
    Returns:
        str: 处理后的文本
        
    Raises:
        ValueError: 当文本为空时抛出异常
    """
    if not text:
        raise ValueError("文本不能为空")
    
    # 实现处理逻辑
    return processed_text
```

### 错误处理
```python
import logging
from typing import Optional

logger = logging.getLogger(__name__)

def safe_operation(data: str) -> Optional[str]:
    """安全执行操作，包含错误处理"""
    try:
        # 执行操作
        result = process_data(data)
        return result
    except Exception as e:
        logger.error(f"操作失败: {e}")
        return None
```

### 配置管理
```python
import json
from pathlib import Path

class ConfigManager:
    def __init__(self, config_path: str = "Resource/config.json"):
        self.config_path = Path(config_path)
        self.config = self.load_config()
        
    def load_config(self) -> dict:
        """加载配置文件"""
        if self.config_path.exists():
            with open(self.config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
        
    def save_config(self) -> None:
        """保存配置文件"""
        with open(self.config_path, 'w', encoding='utf-8') as f:
            json.dump(self.config, f, ensure_ascii=False, indent=2)
```

## 测试指南

### 单元测试
```python
import unittest
from ModuleFolders.TextProcessor.TextProcessor import TextProcessor

class TestTextProcessor(unittest.TestCase):
    def setUp(self):
        self.processor = TextProcessor()
        
    def test_text_cleaning(self):
        """测试文本清理功能"""
        dirty_text = "  Hello World!  \n"
        clean_text = self.processor.clean_text(dirty_text)
        self.assertEqual(clean_text, "Hello World!")
        
    def test_empty_text_handling(self):
        """测试空文本处理"""
        result = self.processor.clean_text("")
        self.assertEqual(result, "")

if __name__ == '__main__':
    unittest.main()
```

### 集成测试
```python
import tempfile
import os
from pathlib import Path

def test_file_translation_workflow():
    """测试完整的文件翻译流程"""
    # 创建临时测试文件
    with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
        f.write("Hello World")
        test_file = f.name
    
    try:
        # 测试翻译流程
        translator = FileTranslator()
        result = translator.translate_file(test_file, target_language='zh')
        
        # 验证结果
        assert result is not None
        assert len(result) > 0
        
    finally:
        # 清理临时文件
        os.unlink(test_file)
```

## 性能优化

### 异步处理
```python
import asyncio
import aiohttp
from concurrent.futures import ThreadPoolExecutor

class AsyncTranslator:
    def __init__(self, max_concurrent: int = 5):
        self.max_concurrent = max_concurrent
        self.semaphore = asyncio.Semaphore(max_concurrent)
        
    async def translate_batch(self, texts: list) -> list:
        """批量异步翻译"""
        tasks = [self.translate_single(text) for text in texts]
        return await asyncio.gather(*tasks)
        
    async def translate_single(self, text: str) -> str:
        """单个文本异步翻译"""
        async with self.semaphore:
            # 实现异步翻译逻辑
            pass
```

### 缓存机制
```python
from functools import lru_cache
import hashlib

class TranslationCache:
    def __init__(self, cache_size: int = 1000):
        self.cache = {}
        self.max_size = cache_size
        
    def get_cache_key(self, text: str, target_lang: str) -> str:
        """生成缓存键"""
        content = f"{text}:{target_lang}"
        return hashlib.md5(content.encode()).hexdigest()
        
    def get(self, text: str, target_lang: str) -> str:
        """获取缓存的翻译"""
        key = self.get_cache_key(text, target_lang)
        return self.cache.get(key)
        
    def set(self, text: str, target_lang: str, translation: str):
        """设置翻译缓存"""
        if len(self.cache) >= self.max_size:
            # 清理最旧的缓存项
            oldest_key = next(iter(self.cache))
            del self.cache[oldest_key]
            
        key = self.get_cache_key(text, target_lang)
        self.cache[key] = translation
```

## 贡献指南

### 提交代码
1. Fork 项目到个人仓库
2. 创建功能分支：`git checkout -b feature/new-feature`
3. 提交更改：`git commit -m "Add new feature"`
4. 推送分支：`git push origin feature/new-feature`
5. 创建 Pull Request

### 代码审查
- 确保代码通过所有测试
- 添加必要的文档和注释
- 遵循项目的代码规范
- 提供清晰的提交信息

### 问题报告
使用 GitHub Issues 报告问题：
1. 提供详细的问题描述
2. 包含重现步骤
3. 提供系统环境信息
4. 附上相关的日志信息

## 调试技巧

### 日志配置
```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('debug.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)
```

### 性能分析
```python
import cProfile
import pstats

def profile_function(func):
    """性能分析装饰器"""
    def wrapper(*args, **kwargs):
        pr = cProfile.Profile()
        pr.enable()
        result = func(*args, **kwargs)
        pr.disable()
        
        stats = pstats.Stats(pr)
        stats.sort_stats('cumulative')
        stats.print_stats(10)  # 显示前10个最耗时的函数
        
        return result
    return wrapper

@profile_function
def expensive_operation():
    # 需要分析的函数
    pass
```

## 发布流程

### 版本管理
- 使用语义化版本控制（Semantic Versioning）
- 格式：MAJOR.MINOR.PATCH
- 在 `version.py` 中维护版本信息

### 构建发布包
```bash
# 清理旧的构建文件
rm -rf build/ dist/

# 构建可执行文件
pyinstaller AiNiee.spec

# 创建发布包
cd dist/
zip -r AiNiee-v1.0.0.zip AiNiee/
```

### 发布检查清单
- [ ] 代码通过所有测试
- [ ] 更新版本号
- [ ] 更新更新日志
- [ ] 构建可执行文件
- [ ] 测试可执行文件
- [ ] 创建 GitHub Release
- [ ] 发布到各个平台